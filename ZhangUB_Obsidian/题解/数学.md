# 质数
## 性质
1. n>3，n和n+1总有一个不是质数
2. 质数有无穷多个
3. 存在任意长的一段连续数，其中所有数都是合数（相邻素数之间的间隔任意大）
    - 令a=(n+1)!,则(a+2)~(a+(n+1))都是合数，因为(a+k)%k=0
4. N以内的素数个数随着N的增大趋近于logn
5. 随着n的增大素数越来越稀疏
6. a到2a之间至少有一个素数
## 猜想
1. 孪生素数猜想：n和n+2都为素数的情况有很多
    3 5,5 7,11 13, 1e9+7 1e9+9
2. 哥德巴赫猜想：任意大于2的正偶数可以写成两个素数和
## 素数判定
1. 暴力枚举
    - 从2到 $\sqrt n$ 暴力枚举
    - $O(\sqrt n)$ 
2. 筛法
    - 埃氏筛
        ```cpp
        for(int i=2;i<=n;i++){
            if(!b[i]) cout << i << ' ';
            for(int j=i+i;j<=n;j+=i){
                b[j]=1;
            }
        }
        ```
        - 优化：j的循环从i*i开始，因为更小的一定已经被筛了
        - $O(nloglogn)$
    - 线性筛(欧拉筛)
        - 用数组v记录最小质因子(质数的是自己)
        - 依次考虑2~N的每一个数
        - 如果`v[i]=i`，那么存储i
        - 扫描小于等于`v[i]`的所有质数p，令`v[i*p]=p`，即在i上积累一个质因子，因为`p<=v[i]`，那么p就是i\*p的最小质因子
        ```cpp
        for(int i=2;i<=n;i++){
            if(v[i]==0){//没筛过的都是素数
                v[i]=i;
                prime[++cnt]=i;
            }
            for(int j=1;j<=cnt;j++){
                if(prime[j]>v[i]||i*prime[j]>n) break;
                v[i*prime[j]]=prime[j];
            }
        }
        ```
        - $O(n)$
3. 算数基本定理
    - 任何大于1的正整数都能唯一分解成有限个质数的乘积
    - 记作：$N=p_1^{c_1}p_2^{c_2}p_1^{c_3}…p_n^{c_n}$
    - 推论1：N的正约数合集就是右式枚举指数，约数个数等于指数+1再累乘
    - 推论2：可以进一步枚举求解正约数的和
    - 推论3：int范围内最多10个质因子累乘
4. gcd和lcm
    - gcd
        - 辗转相除法
            - gcd(a,b)=gcd(b,a-b)=gcd(b,a%b)
            - 证明：设gcd(a,b)=d
                a=id,b=jd,a-b=(i-j)d
                说明d是公因子
                设d不是最大的公因子,c是,c>d
                则b=kc,a-b=lc
                a=(k+l)c
                说明c是a和b的最大公因子，则与最初矛盾
        ```cpp
        long long gcd(long long a,long long b){
            return b?gcd(b,a%b):a;
        }
        ```
    - lcm
        - lcm=a*b/gcd
5. 欧拉函数
    - 两个数gcd=1,两个数互质
    - 1到n中互质的数的个数称为欧拉函数
    - $f(n)=n*\frac{p_1-1}{p_1}*\frac{p_2-1}{p_2}*…*\frac{p_n-1}{p_n}$
    - 性质：若a，b互质，$f(a*b)=f(a)*f(b)$--积性函数
