# 线段树
- 平衡二叉树，最大深度logn
- 每个结点代表对应一个区间
- 每个结点完全包含它的所有子孙结点
- 任意两个结点要么互不相交，要么完全包含
```cpp
//单点查询和修改
const int n=101010;
int tree[4*101010];//最多4倍

void build(int p,int l,int r){
    if(l==r){
        tree[p]=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void change(int p,int l,int r,int pos,int num){
    if(l==r){
        tree[p]+=num;
    }
    int mid=(l+r)>>1;
    if(pos<=mid) change(p*2,l,mid,pos,num);
    else change(p*2+1,mid+1,r,pos,num);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void calc(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y) return tree[p];
    int mid=(l+r)>>1;
    // if(y<=mid) calc(p*2,l,mid,x,y);
    // if(x>mid) calc(p*2+1,mid+1,r,x,y);
    // return calc(p*2,l,mid,x,y)+calc(p*2+1,mid+1,r,x,y);
    int ans=0;
    if(x<=mid) ans+=calc(p*2,l,mid,x,y);
    if(y>mid) ans+=calc(p*2+1,mid+1,r,x,y);
    return ans;
}
```
- 还有部分问题涉及给整个区间修改，贴一个区间加的代码
```cpp
void pushdown(int p,int l,int r){
    int mid=(l+r)>>1;
    laz[p*2]+=laz[p];
    laz[p*2+1]+=laz[p];
    tree[p*2]+=laz[p]*(mid-l+1);
    tree[p*2+1]+=laz[p]*(r-(mid+1)+1);
    laz[p]=0;
}

void change(int p,int l,int r,int x,int y,int num){
    if(x<=l&&y<=r){
        tree[p]+=num*(r-l+1);
        laz[p]+=num;
        return ;
    }
    if(laz[p]!=0) pushdown(p,l,r);//laz向下传递
    int mid=(l+r)>>1;
    if(x<=mid) change(p*2,l,mid,x,y,num);
    if(y>mid) change(p*2+1,mid+1,r,x,y,num);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void calc(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y) return tree[p];
    int mid=(l+r)>>1;
    if(laz[p]!=0) pushdpwn(p,l,r);
    // if(y<=mid) calc(p*2,l,mid,x,y);
    // if(x>mid) calc(p*2+1,mid+1,r,x,y);
    // return calc(p*2,l,mid,x,y)+calc(p*2+1,mid+1,r,x,y);
    int ans=0;
    if(x<=mid) ans+=calc(p*2,l,mid,x,y);
    if(y>mid) ans+=calc(p*2+1,mid+1,r,x,y);
    return ans;
}
```