# 线段树
## tips
- 区间操作，且左右两个子区间可以合并成父亲区间——考虑线段树
- 有区间性的操作——lazy标记
- 不知道子区间具体情况，能处理区间的整体情况的结果——才可以使用lazy标记
- 不得不暴力完成操作，但是若干次操作后区间就无效了(线段覆盖，求区间开根若干次区间和)，可以给每个区间维护一个——cover标记，表示整个区间再进行操作已经没用了，查询和修改就能优化速度(区间被覆盖若干次后就被完全覆盖/开根若干次整个区间所有值都变成1)
- 求一些比较复杂(函数结果带小数)的区间和，如: $\sum sin{x_i}, \,\, \sum{\sqrt{x_i}}, \,\, \sum{\frac{1}{x_i}}$ 都把要求的式子做泰勒展开(展开到6次左右)，然后维护多个树
## 性质
- 平衡二叉树，最大深度logn
- 每个结点代表对应一个区间
- 每个结点完全包含它的所有子孙结点
- 任意两个结点要么互不相交，要么完全包含
## 代码
```cpp
//单点查询和修改
const int n=101010;
int tree[4*101010];//最多4倍

void build(int p,int l,int r){
    if(l==r){
        tree[p]=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void change(int p,int l,int r,int pos,int num){
    if(l==r){
        tree[p]+=num;
    }
    int mid=(l+r)>>1;
    if(pos<=mid) change(p*2,l,mid,pos,num);
    else change(p*2+1,mid+1,r,pos,num);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void calc(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y) return tree[p];
    int mid=(l+r)>>1;
    // if(y<=mid) calc(p*2,l,mid,x,y);
    // if(x>mid) calc(p*2+1,mid+1,r,x,y);
    // return calc(p*2,l,mid,x,y)+calc(p*2+1,mid+1,r,x,y);
    int ans=0;
    if(x<=mid) ans+=calc(p*2,l,mid,x,y);
    if(y>mid) ans+=calc(p*2+1,mid+1,r,x,y);
    return ans;
}
```
- 还有部分问题涉及给整个区间修改，贴一个区间加的代码
```cpp
void pushdown(int p,int l,int r){
    int mid=(l+r)>>1;
    laz[p*2]+=laz[p];
    laz[p*2+1]+=laz[p];
    tree[p*2]+=laz[p]*(mid-l+1);
    tree[p*2+1]+=laz[p]*(r-(mid+1)+1);
    laz[p]=0;
}

void change(int p,int l,int r,int x,int y,int num){
    if(x<=l&&y<=r){
        tree[p]+=num*(r-l+1);
        laz[p]+=num;
        return ;
    }
    if(laz[p]!=0) pushdown(p,l,r);//laz向下传递
    int mid=(l+r)>>1;
    if(x<=mid) change(p*2,l,mid,x,y,num);
    if(y>mid) change(p*2+1,mid+1,r,x,y,num);
    tree[p]=tree[p*2]+tree[p*2+1];
}
void calc(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y) return tree[p];
    int mid=(l+r)>>1;
    if(laz[p]!=0) pushdpwn(p,l,r);
    // if(y<=mid) calc(p*2,l,mid,x,y);
    // if(x>mid) calc(p*2+1,mid+1,r,x,y);
    // return calc(p*2,l,mid,x,y)+calc(p*2+1,mid+1,r,x,y);
    int ans=0;
    if(x<=mid) ans+=calc(p*2,l,mid,x,y);
    if(y>mid) ans+=calc(p*2+1,mid+1,r,x,y);
    return ans;
}
```

# 树状数组
- 解决能通过父节点和一个子节点得到另一个子节点的问题(**可减**)
- 长度永远是2的多少次方，一般开2n
- 1-base数组下标的末尾0个数表示覆盖长度
- lowbit找上一条
- 单点修改不断往上传idx->idx+lowbit(idx)
- 查询前缀和实现
```cpp
int lowbit(int x){ return x&(-x); }
//-x是x取反+1
void add(int i,int val){
    while(i<=n){
        c[i]+=val;
        i+=lowbit(i);
    }
}

int sum(int i){
    int s=0;
    while(i>0){
        s+=c[i];
        i-=lowbit(i);
    }
    return s;
}
``` 
# 分块
- 一种简陋的线段树，使得一个块和一个点的修改同样快，快的大小一般取 $\sqrt(n)$