# 质数
## 性质
1. n>3，n和n+1总有一个不是质数
2. 质数有无穷多个
3. 存在任意长的一段连续数，其中所有数都是合数（相邻素数之间的间隔任意大）
    - 令a=(n+1)!,则(a+2)~(a+(n+1))都是合数，因为(a+k)%k=0
4. N以内的素数个数随着N的增大趋近于$n/ln(n)$
5. 随着n的增大素数越来越稀疏
6. a到2a之间至少有一个素数
## 猜想
1. 孪生素数猜想：n和n+2都为素数的情况有很多
    3 5,5 7,11 13, 1e9+7 1e9+9
2. 哥德巴赫猜想：任意大于2的正偶数可以写成两个素数和
## 素数判定
1. 暴力枚举
    - 从2到 $\sqrt n$ 暴力枚举
    - $O(\sqrt n)$ 
2. 筛法
    - 埃氏筛
        ```cpp
        for(int i=2;i<=n;i++){
            if(!b[i]) cout << i << ' ';
            for(int j=i+i;j<=n;j+=i){
                b[j]=1;
            }
        }
        ```
        - 优化：j的循环从i*i开始，因为更小的一定已经被筛了
        - $O(nloglogn)$
    - 线性筛(欧拉筛)
        - 用数组v记录最小质因子(质数的是自己)
        - 依次考虑2~N的每一个数
        - 如果`v[i]=i`，那么存储i
        - 扫描小于等于`v[i]`的所有质数p，令`v[i*p]=p`，即在i上积累一个质因子，因为`p<=v[i]`，那么p就是i\*p的最小质因子
        ```cpp
        for(int i=2;i<=n;i++){
            if(v[i]==0){//没筛过的都是素数
                v[i]=i;
                prime[++cnt]=i;
            }
            for(int j=1;j<=cnt;j++){
                if(prime[j]>v[i]||i*prime[j]>n) break;
                v[i*prime[j]]=prime[j];
            }
        }
        ```
        - $O(n)$
3. 算数基本定理
    - 任何大于1的正整数都能唯一分解成有限个质数的乘积
    - 记作：$N=p_1^{c_1}p_2^{c_2}p_1^{c_3}…p_n^{c_n}$
    - 推论1：N的正约数合集就是右式枚举指数，约数个数等于指数+1再累乘
    - 推论2：可以进一步枚举求解正约数的和
    - 推论3：int范围内最多10个质因子累乘
## gcd和lcm
- gcd
	- 辗转相除法
		- gcd(a,b)=gcd(b,a-b)=gcd(b,a%b)
		- 证明：设gcd(a,b)=d
			a=id,b=jd,a-b=(i-j)d
			说明d是公因子
			设d不是最大的公因子,c是,c>d
			则b=kc,a-b=lc
			a=(k+l)c
			说明c是a和b的最大公因子，则与最初矛盾
	```cpp
	long long gcd(long long a,long long b){
		return b?gcd(b,a%b):a;
	}
	```
- lcm
	- lcm=a*b/gcd
## 欧拉函数
- 两个数gcd=1,两个数互质
- 1到n中和n互质的数的个数称为欧拉函数
- $f(n)=n*\frac{p_1-1}{p_1}*\frac{p_2-1}{p_2}*…*\frac{p_n-1}{p_n}$
- 性质：若a，b互质，$f(a*b)=f(a)*f(b)$--积性函数
# 同余
- a和b除m的余数相等，a和b模m同余，记作a=b(mod m)
- 反身性，对称性，传递性
## 同余类与剩余系
- 集合中所有数模m同余，该集合是一个模m的同余类，记作 $\overline{a}$
- 模m的同余类共有m个，构成m的完全剩余系 $\overline{0}$,$\overline{1}$,$\overline{2}$…$\overline{m-1}$
## 费马小定理
- 若p是质数，则对于任意不能被p整除的整数a，有 $a^{p-1} \equiv 1(\,{mod}\,{p}\,)$
- 或者：p是质数，对于任意整数 $a^p \equiv a(\,mod\,p\,)$
- 应用：解决mod意义下除法
    - 由于 $a^{p-1} \equiv 1(\,{mod}\,{p}\,)$ 则 $a*a^{p-2}\equiv 1 (\,mod\,p\,)$ 则除a等价于乘a的p-2次方(用快速幂求)
## 欧拉定理
- 如果n和a互质，则 $a^{pi(n)} \equiv 1(\\,mod\,n)$ ，其中pi(n)为欧拉函数
- 推论-欧拉降幂公式：如果n和a互质，则有 $a^b\equiv a^{b\,mod\,pi(n)}$ 
## 裴蜀定理-扩展欧几里得算法
- 对于两个不全为0的整数a，b，存在x，y使得
    - $ax+by=gcd(a,b)$
- **求x，y**
```cpp
typedef long long ll
ll gcd_ex(ll a,ll b,ll &x,ll &y){
    if(b==0){ x=1;y=0;return a;}
    ll d=gcd_ex(b,a%b,y,x);
    y=y-a/b*x;
    return d;
}
```
## 二元一次不定方程的通解
- 已知一组解，求通解
- ax+by=c的通解为
    - x=x0-b1\*t
    - y=y0-a1\*t
    - 其中,a1=a/gcd(a,b),b1=b/(a,b)
- 二元一次不定方程ax+by=c有解的充要条件是
    - gcd(a,b)|c
## 一元一次同余方程
- $ax\equiv b(\,mod\,m\,)$ 转换为ax+km=b
## 逆元
- 模运算的除等于乘上逆元
- $ax\equiv 1(\,mod\,m)$ 
    - 费马小定理：m必须是质数,逆元 $a^{p-2}$
    - 欧拉定理：a和m互质,逆元 $a^{pi(p)-1}$
    - 同余方程求解：不满足上两个
## 中国剩余定理
- 求解同余方程，形如下式的方程组
    x ≡ a₁ mod m₁  
    x ≡ a₂ mod m₂  
    ...  
    x ≡ a_k mod m_k
- 条件：所有的模数两两互质，则有解，且在模数乘积M=m₁×m₂×...×m_k意义下解是唯一的
```cpp
// 扩展欧几里得算法：求 ax + by = gcd(a, b)
long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    long long d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

// 中国剩余定理模板函数（模数两两互质）
long long CRT(const vector<long long>& a, const vector<long long>& m) {
    int n = a.size();
    long long M = 1; // 所有模数乘积
    for (int i = 0; i < n; ++i) M *= m[i];
    long long res = 0;
    for (int i = 0; i < n; ++i) {
        long long Mi = M / m[i];
        long long inv, y;
        exgcd(Mi, m[i], inv, y);
        inv = (inv % m[i] + m[i]) % m[i]; // 保证正数
        res = (res + a[i] * Mi % M * inv % M) % M;
    }
    return (res % M + M) % M; // 保证非负解
}
int main() {
    // 示例: 解 x ≡ 2 mod 3, x ≡ 3 mod 5, x ≡ 2 mod 7
    vector<long long> a = {2, 3, 2}; // 余数
    vector<long long> m = {3, 5, 7}; // 模数（两两互质）
    long long x = CRT(a, m);
    cout << "x ≡ " << x << " mod " << (3 * 5 * 7) << endl; // 输出 x ≡ 23 mod 105

    return 0;
}

```
# 组合数学
## 加法原理和乘法原理
## 排列
- $A_n^m$ 从n个数里选m个作排列
- $A_n^m=\frac{n!}{(n-m)!}$
## 组合
- $C_n^m$ 从n个数里选m个作组合
- $C_n^m=\frac{n!}{m!(n-m)!}$
- $C_n^m=C_n^{n-m}$
- $C_n^m=C_{n-1}^{m}+C_{n-1}^{m-1}$
- $\sum_{i=1}^{n}C_n^i=2^n$ 等价于考虑每个元素选和不选
## 二项式定理
- $(a+b)^n=\sum_{i=1}^{n}C_n^{i}a^{n-i}b^i$
- 可以写杨辉三角看
## 错排问题
- 本质：长为n的排列，第i位不能放i，求方案数
- 计算方法：
    - 对于任意一个数k，可放置的位置有n-1个，假设它放置在第j位上
    - 这时考虑j，如果把j放在第k位上，则构成大小为n-2的子问题，如果没放在第k位上，就变成大小为n-1的子问题(第k位不能放j，剩下n-2个数有对应的限制)
    - 递推式： $f(n)=(n-1)*(f(n-1)+f(n-2))$
- 同类问题：棋盘落子
## 卡特兰数
- $f(n)=C^n_{n+m}-C^{n+1}_{n+m}$
- 通常情况下，要求合法意味着n=m
- 应用：长度为k的合法括号序列，n个元素的合法出栈序列，n+2边凸多边形用不相交对角线划分为三角形的方法数为f(n)
## 鸽巢原理
- n+1只格子飞回n个鸽巢，至少有一个鸽巢有不少于两只鸽子
## 容斥原理
- $A \cup B \cup C=A+B+C-(A \cap B) - (B\cap C)-(C\cap A) +(A\cap B\cap C)$
- 偶数交集减去，奇数并集加上
# 矩阵乘法
## 性质
- 结合律： $(AB)C=A(BC)$
- 左分配率，右分配率： $(A+B)*C=AC+BC,\,C*(A+B)=CA+CB$
- 数乘结合律： $k(AB)=A(kB)$
## 用途
- 求斐波那契数列：构建一个2*2的矩阵(0,1,1,1)使得$(f(1),f(2))$->$(f(2),f(3))$，发现每乘一次就提高一次，又由于左侧矩阵可以使用矩阵快速幂，则可以先计算左侧矩阵的n次方，再得到总共的结果
- 矩阵快速幂

# 博弈论
## NIM取子游戏
- 若干堆，轮流取子，拿光的赢
- 异或和为0是必败态，不为0为必胜态
## 巴什博弈变式——组合博弈
- n堆石子，每堆a_i个，每人每次可以取1~4，谁获胜
- 每一堆会有必胜态1或必败态0，看这些堆的异或和

# 概率
- 布冯投针

# 数论分块
- 只枚举小于根号n的部分，大于的部分换另一种算法