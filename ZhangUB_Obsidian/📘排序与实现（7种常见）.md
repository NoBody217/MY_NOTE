## 选择排序

**原理**：每次从未排序部分中选择最小元素，放到已排序部分的末尾。
**时间复杂度**：
- 最好/最坏/平均：O(n²)
**特点**：
- 不稳定
- 原地排序
### ✅ C 代码实现：

```c
void selectionSort(int k[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (k[j] < k[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(&k[i], &k[minIndex]);
        }
    }
}
```

---

## 冒泡排序

**原理**：相邻元素两两比较，大的往后移，一趟下来最大的“冒”到最后。
**时间复杂度**：
- 最好：O(n)（优化后）
- 最坏/平均：O(n²)
**特点**：
- 稳定
- 原地排序
### ✅ C 代码实现：

```c
void bubbleSort(int k[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int flag = 0;
        for (int j = 0; j < n - i - 1; j++) {
            ans++;
            if (k[j] > k[j + 1]) {
                swap(&k[j], &k[j + 1]);
                flag=1;
            }
        }
        if (flag == 0) {
            break;
        }       
    }
}
```
### 优化方法： **添加标志位**
- 在每趟排序中设立一个标志位 `flag`。
- 如果这一趟中没有发生任何交换，说明已经有序，可以提前结束排序。
```c
void bubbleSort(int k[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int flag = 0;  // 标志：是否发生交换
        for (int j = 0; j < n - i - 1; j++) {
            ans++;
            if (k[j] > k[j + 1]) {
                swap(&k[j], &k[j + 1]);
                flag = 1;
            }
        }
        if (flag == 0)  // 如果没有交换，提前退出
            break;
    }
}
```

---

## 堆排序（详细讲解）
### 📚 排序原理
堆排序的核心是使用**完全二叉树**实现一个**大根堆**（或小根堆）来排序。过程分为两个阶段：
#### 1. **建堆阶段（Heapify）**
- 将无序数组调整成**大根堆**。
- 从最后一个非叶节点 `n/2 - 1` 向前依次下沉（调用 `adjust`）。
	- 关于为什么最后一个非叶结点是`n/2-1`:对于二叉树，叶子节点的范围是`[n/2,n]`,第一个叶子节点-1就是最后一个非叶子节点
#### 2. **排序阶段（弹出并重建堆）**
- 每次将堆顶元素（最大值）与末尾元素交换。
- 然后对新的堆顶执行 `adjust`，保持堆结构。
- 重复此过程，直到堆大小为1。
### 🔢 索引规律（0-base二叉树）
对于数组 `arr[]` 中任意节点 `i`：
- 左子节点：`2i + 1`
- 右子节点：`2i + 2`
- 父节点：`(i - 1) / 2`
---
### ✳️ 构建初始堆（大根堆）
#### 示例数组
```c
int arr[] = {5, 3, 8, 4, 1, 6};
```
初始二叉树结构（按数组索引）：
```
        5
       / \
      3   8
     / \   \
    4   1   6
```
#### Step-by-step 建堆过程
##### 从 `i = 2`（值 8）开始
- 子节点：`6`，满足 8 ≥ 6，不动
##### 从 `i = 1`（值 3）
- 子节点：4 和 1，最大是 4 → 交换
- 数组变为：`{5, 4, 8, 3, 1, 6}`
树形结构：
```
        5
       / \
      4   8
     / \   \
    3   1   6
```
##### 从 `i = 0`（值 5）
- 子节点：4 和 8，最大是 8 → 交换
- 数组变为：`{8, 4, 5, 3, 1, 6}`
最终大根堆结构：
```
        8
       / \
      4   5
     / \   \
    3   1   6
```
---
### ⛓️ 排序阶段（弹出堆顶并重建）
#### 初始堆：`{8, 4, 5, 3, 1, 6}`
---
#### 弹出最大值 8（与末尾 6 交换）
数组变为：`{6, 4, 5, 3, 1, 8}`  
调整堆大小为 `5`
##### 调整堆顶（6）下沉：
- 子节点：4 和 5 → 最大为 5 → 交换 6 和 5
- 数组变为：`{5, 4, 6, 3, 1, 8}`
新堆结构：
```
        5
       / \
      4   6
     / \
    3   1
```
---
#### 弹出最大值 5（与末尾 1 交换）
数组变为：`{1, 4, 6, 3, 5, 8}`  
调整堆大小为 `4`
##### 调整堆顶（1）下沉：
- 子节点：4 和 6 → 最大为 6 → 交换
- 再次比较 1 和其子节点（无） → 完成
- 数组变为：`{6, 4, 1, 3, 5, 8}`
堆结构：
```
        6
       / \
      4   1
     /
    3
```
---
#### 弹出最大值 6（与末尾 3 交换）
数组变为：`{3, 4, 1, 6, 5, 8}`  
调整堆大小为 `3`
##### 调整堆顶（3）：
- 子节点：4 和 1 → 最大为 4 → 交换
- 数组变为：`{4, 3, 1, 6, 5, 8}`
堆结构：
```
        4
       / \
      3   1
```
---
#### 继续弹出直至排序完成
最终得到排序数组（升序）：
```c
{1, 3, 4, 5, 6, 8}
```
### ✅ C 代码实现：
```c
// 下沉调整函数
void adjust(int k[], int i, int n){
    int j, temp;
    temp = k[i];         // 当前父节点的值
    j = 2 * i + 1;       // 左孩子
    while (j < n) {
        if (j < n - 1 && k[j] < k[j + 1]) // 取左右中最大孩子
            j++;
        ans++;
        if (temp >= k[j]) // 父节点比子节点大，满足大根堆
            break;
        k[(j - 1) / 2] = k[j]; // 向上提子节点
        j = 2 * j + 1;         // 继续向下
    }
    k[(j - 1) / 2] = temp;
}
// 主排序函数
void heapSort(int k[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--)  // 建堆
        adjust(k, i, n);
    for (int i = n - 1; i > 0; i--) {     // 排序
        swap(&k[0], &k[i]);               // 交换堆顶与最后
        adjust(k, 0, i);                  // 调整堆
    }
}

```
---
## 归并排序

**原理**：采用**分治法**，不断划分子数组，直到子数组有序，再合并。
**时间复杂度**：
- 最好/最坏/平均：O(n log n)
**特点**：
- 稳定
- 需要 O(n) 额外空间（非原地排序）
### ✅ C 代码实现：

```c
void merge(int x[], int tmp[], int left, int leftend, int rightend) {
    int i = left, j = leftend + 1, q = left;
    while (i <= leftend && j <= rightend) {
        ans++;
        if (x[i] <= x[j])
            tmp[q++] = x[i++];
        else
            tmp[q++] = x[j++];
    }
    while (i <= leftend)
        tmp[q++] = x[i++];
    while (j <= rightend)
        tmp[q++] = x[j++];
    for (i = left; i <= rightend; i++)
        x[i] = tmp[i];
}

void mergeSort(int x[], int tmp[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(x, tmp, left, mid);
        mergeSort(x, tmp, mid + 1, right);
        merge(x, tmp, left, mid, right);
    }
}
```

---
## 快速排序

**原理**：选择一个“基准”元素，将数组划分为小于基准和大于基准两部分，递归排序。
**时间复杂度**：
- 最好/平均：O(n log n)
- 最坏：O(n²)（当数组接近有序）
**特点**：
- 不稳定
- 原地排序
### ✅ C 代码实现：

```c
void quickSort(int k[], int left, int right) {
    int i, last;
    if (left < right) {
        last = left;
        for (i = left + 1; i <= right; i++) {
            ans++;
            if (k[i] < k[left]) {
                swap(&k[++last], &k[i]);
            }
        }
        swap(&k[left], &k[last]);
        quickSort(k, left, last - 1);
        quickSort(k, last + 1, right);
    }
}
```

---
## 插入排序

**原理**：将当前元素插入到前面已经有序的序列中，保证前缀始终有序。
**过程**：
- 从第二个元素开始（下标 1），将其与左边元素比较，如果更小就向前插入
- 插入时伴随元素的后移
- 适用于数据量小或基本有序的情况
**时间复杂度**：
- 最好：O(n)
- 平均/最坏：O(n²)
**特点**：
- 稳定
- 原地排序，空间复杂度 O(1)
### ✅ C 代码实现：
```c
void insertionSort(int a[], int n) {
    for (int i = 1; i < n; i++) {
        int temp = a[i];
        int j = i - 1;
        while (j >= 0 && a[j] > temp) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
    }
}
```

---

## 希尔排序(避免了插入排序的一一后移,跨大步走)

**原理**：是插入排序的改进版。通过设置步长（gap）将元素分组，对每组进行插入排序，使整体逐步趋近有序，最后再对全体做一次插入排序。
**过程**：
1. 设定初始 gap = n/2
2. 将 gap 间隔的元素视作一组，对每组做插入排序
3. gap 不断缩小（例如 gap /= 2），直到为 1，最后整体插入排序完成
### 示例：
排序 `{9, 8, 3, 7, 5, 6, 4, 1}`，n = 8
- 初始 gap = 4 → 分组：`{9,5}`、`{8,6}`、`{3,4}`、`{7,1}`
- 每组插入排序后 → `{5,6,3,1,9,8,4,7}`
- gap = 2 → 分组 `{5,3,9,4}` 和 `{6,1,8,7}` → 插入排序
- 最后 gap = 1 → 整体插入排序完成 → `{1,3,4,5,6,7,8,9}`
**时间复杂度**（取决于 gap 序列）：
- 最好：O(n log n)
- 最坏：O(n²)
**特点**：
- 不稳定
- 原地排序，空间复杂度 O(1)
- 对中等规模数据有较好性能
### ✅ C 代码实现：

```c
void shellSort(int a[], int n) {
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            int temp = a[i];
            int j;
            for (j = i; j >= gap && a[j - gap] > temp; j -= gap) {
                a[j] = a[j - gap];
            }
            a[j] = temp;
        }
    }
}
```
